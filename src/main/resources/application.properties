spring.application.name=tesis_bachiller_backend_multimodular

# --- GitHub OAuth2 Client Configuration ---
# �IMPORTANTE! Estos valores NO deben ser versionados.
# Se resuelven desde variables de entorno para mantener los secretos fuera del c�digo fuente.
# export SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GITHUB_CLIENT_ID='tu_client_id'
# export SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GITHUB_CLIENT_SECRET='tu_client_secret'
spring.security.oauth2.client.registration.github.client-id=${SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GITHUB_CLIENT_ID}
spring.security.oauth2.client.registration.github.client-secret=${SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GITHUB_CLIENT_SECRET}
spring.security.oauth2.client.registration.github.scope=read:user,user:email
spring.security.oauth2.client.registration.github.redirect-uri=${OAUTH2_GITHUB_REDIRECT_URI}



# --- Database Configuration (MySQL) ---
# Estos valores se resuelven desde variables de entorno.
# Para desarrollo local con Docker, puedes usar algo como:
# export JDBC_DATABASE_URL='jdbc:mysql://localhost:3306/tesisdb?createDatabaseIfNotExist=true'
# export JDBC_DATABASE_USERNAME='root'
# export JDBC_DATABASE_PASSWORD='your_local_password'
spring.datasource.url=${JDBC_DATABASE_URL}
spring.datasource.username=${JDBC_DATABASE_USERNAME}
spring.datasource.password=${JDBC_DATABASE_PASSWORD}


# --- JPA / Hibernate Configuration ---
# 'create-drop' crear� el esquema al arrancar y lo destruir� al parar. Ideal para desarrollo.
spring.jpa.hibernate.ddl-auto=create-drop
# Especifica el dialecto de MySQL para que Hibernate genere el SQL correcto.
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect


# --- Application Specific Configuration ---
dora.initial-admin-username=grubhart
dora.github.workflow-file-name=manual-deploy.yml

# --- Frontend Configuration ---
app.frontend.url=${APP_FRONTEND_URL}

# --- Server Configuration ---
# Permite que Spring Boot construya las URLs de redirecci�n correctamente cuando se ejecuta detr�s de un proxy (como en AWS)
server.forward-headers-strategy=NATIVE

# --- Session Configuration ---
# Spring Session JDBC: Almacena sesiones en MySQL para compartirlas entre instancias
spring.session.store-type=jdbc
# Usamos schema.sql manual en lugar de auto-inicialización
spring.session.jdbc.initialize-schema=never
spring.session.timeout=24h

# --- Session Cookie Configuration ---
# Asegura que la cookie de sesi�n funcione en un contexto cross-site con HTTPS
server.servlet.session.cookie.secure=true
server.servlet.session.cookie.same-site=None

# Poner el nivel de log en DEBUG para nuestro paquete espec�fico
logging.level.org.grubhart.pucp.tesis=DEBUG

# --- Spring Session Logging ---
logging.level.org.springframework.session=DEBUG
logging.level.org.springframework.jdbc.datasource.init=DEBUG

# --- Hibernate/JPA Detailed Logging ---
# Muestra las sentencias SQL que Hibernate genera.
logging.level.org.hibernate.SQL=error
# Muestra los par�metros que se enlazan a las sentencias SQL (�muy �til!).
#logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
# Muestra informaci�n sobre las transacciones (begin, commit, rollback).
logging.level.org.springframework.transaction=error
# Formatea el SQL para que sea m�s legible en los logs.
spring.jpa.properties.hibernate.format_sql=true

# --- Database Initialization ---
# Asegura que los scripts de datos (data.sql) se ejecuten DESPU�S de que Hibernate (JPA) haya creado las tablas.
spring.jpa.defer-datasource-initialization=true

management.endpoints.web.exposure.include=health

server.address=0.0.0.0
